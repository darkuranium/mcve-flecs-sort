#include <flecs.h>

#include <assert.h>
#include <stdatomic.h>
#include <stdio.h>


// ========== CONFIG ==========
#define MCVE_RUN_FOREVER    0   // run forever, to enable using the online explorer
#define MCVE_MULTITHREADED  0   // use multiple threads (hardcoded to 8, for MCVE's sake)

#define MCVE_SORT_RENDER    1   // whether to sort the render or not; sorting triggers the bug
// ========== END CONFIG ==========


static int32_t expectedCount;
static atomic_int_least32_t actualCount;


// ========== RENDERER ==========

// we need two components to reproduce the bug; depending on just `Position` isn't enough
typedef struct Sprite
{
    char* name;
} Sprite;

typedef struct Position
{
    int32_t x, y;
} Position;

// basically ECS_SYSTEM_DEFINE(...), but with .order_by & .order_by_component
#define ECS_SYSTEM_DEFINE_ORDER_BY(world, id_, phase, order_by_component_, order_by_, ...) \
{ \
        ecs_system_desc_t desc = {0}; \
        ecs_entity_desc_t edesc = {0}; \
        edesc.id = ecs_id(id_);\
        edesc.name = #id_;\
        edesc.add[0] = ((phase) ? ecs_pair(EcsDependsOn, (phase)) : 0); \
        edesc.add[1] = (phase); \
        desc.entity = ecs_entity_init(world, &edesc);\
        desc.query.filter.expr = #__VA_ARGS__; \
        desc.query.order_by_component = (order_by_component_); \
        desc.query.order_by = (order_by_); \
        desc.callback = id_; \
        ecs_id(id_) = ecs_system_init(world, &desc); \
} \
    ecs_assert(ecs_id(id_) != 0, ECS_INVALID_PARAMETER, NULL);

static void SysRenderSprites(ecs_iter_t* it)
{
    //const Sprite* s = ecs_field(it, Sprite, 1);
    //const Position* p = ecs_field(it, Position, 2);

    // add up the count, for debugging
    atomic_fetch_add(&actualCount, it->count);
}
static int SysRenderSprites_cmp(ecs_entity_t e1, const void* ptr1, ecs_entity_t e2, const void* ptr2)
{
    Position p1 = *(const Position*)ptr1;
    Position p2 = *(const Position*)ptr2;

    if(p1.y < p2.y) return -1;
    if(p1.y > p2.y) return +1;
    // if `y` is the same, sort `x`
    if(p1.x < p2.x) return -1;
    if(p1.x > p2.x) return +1;
    // if both are the same, sort by entity ID (to make it fully deterministic and avoid flicker)
    if(e1 < e2) return -1;
    if(e1 > e2) return +1;
    // everything matches
    return 0;
}
// ========== END RENDERER ==========


static ecs_world_t* ecs;

static void initECS(void)
{
    // (to help with debugging)
    ECS_IMPORT(ecs, FlecsMonitor);
    ecs_singleton_set(ecs, EcsRest, {0});

    ECS_COMPONENT(ecs, Sprite);
    ECS_COMPONENT(ecs, Position);

    ECS_SYSTEM_DECLARE(SysRenderSprites);
#if MCVE_SORT_RENDER
    ECS_SYSTEM_DEFINE_ORDER_BY(ecs, SysRenderSprites, EcsOnUpdate,
                               ecs_id(Position), SysRenderSprites_cmp,
                               [in] Sprite, [in] Position);
#else
    ECS_SYSTEM_DEFINE_ORDER_BY(ecs, SysRenderSprites, EcsOnUpdate,
                               0, NULL,
                               [in] Sprite, [in] Position);
#endif

    // we need both prefabs to reproduce the bug; just one isn't enough
    ECS_PREFAB(ecs, AWall);
    ecs_set(ecs, AWall, Sprite, { "Wall" });

    ECS_PREFAB(ecs, AGold);
    ecs_set(ecs, AGold, Sprite, { "Gold" });

    {
#define ADD_BUILDING(x, y, Archetype) \
        (++expectedCount, ecs_set(ecs, ecs_new_w_pair(ecs, EcsIsA, (Archetype)), Position, {(x), (y)}))

        // the bug seems to depend on y for AGold *not* starting at 0
        for(size_t y = 23; y < 25; y++)
            for(size_t x = 0; x < 2; x++)
                ADD_BUILDING(x, y, AGold);

        for(size_t i = 0; i < 10; i++)
        {
            ADD_BUILDING(25, i, AWall);
            ADD_BUILDING(i, 25, AWall);
        }
    }

    fflush(stderr); // for any FLECS errors, to print them before anything else
}

int main(int argc, char** argv)
{
    ecs = ecs_init_w_args(argc, argv);
    assert(ecs);
#if MCVE_MULTITHREADED
    ecs_set_threads(ecs, 8);
#endif

    initECS();

#if MCVE_RUN_FOREVER
    for(;;)
#endif
    {
        atomic_store(&actualCount, 0);

        ecs_progress(ecs, 0.0f);

        printf("COUNT = %d (expected: %d)\n", atomic_load(&actualCount), expectedCount);
        fflush(stdout);
    }

    bool ok = !ecs_fini(ecs);
    assert(ok);

    return 0;
}
